<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excalidraw ‚Üí ASCII</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 8px;
            color: #fff;
        }

        .subtitle {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 24px;
        }

        .dropzone {
            border: 2px dashed #444;
            border-radius: 12px;
            padding: 48px 32px;
            text-align: center;
            background: #252525;
            transition: all 0.2s;
            cursor: pointer;
            margin-bottom: 24px;
        }

        .dropzone:hover, .dropzone.dragover {
            border-color: #666;
            background: #2a2a2a;
        }

        .dropzone.dragover {
            border-color: #4a9eff;
        }

        .dropzone-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.6;
        }

        .dropzone-text {
            color: #aaa;
            font-size: 0.95rem;
        }

        .dropzone-text strong {
            color: #fff;
        }

        input[type="file"] {
            display: none;
        }

        .output-section {
            display: none;
        }

        .output-section.visible {
            display: block;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .section-title {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #888;
        }

        .btn {
            background: #333;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #444;
        }

        .btn-primary {
            background: #4a9eff;
        }

        .btn-primary:hover {
            background: #3a8eef;
        }

        .output-container {
            background: #0d0d0d;
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
        }

        pre {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 13px;
            line-height: 1.4;
            color: #e0e0e0;
            white-space: pre;
            margin: 0;
        }

        .stats {
            margin-top: 12px;
            font-size: 0.8rem;
            color: #666;
        }

        .error {
            background: #3d1f1f;
            border: 1px solid #5d2f2f;
            color: #ff8888;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            display: none;
        }

        .error.visible {
            display: block;
        }

        .options {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option label {
            font-size: 0.85rem;
            color: #aaa;
        }

        .option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #4a9eff;
        }

        .option input[type="number"] {
            width: 64px;
            background: #333;
            border: 1px solid #444;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® Excalidraw ‚Üí ASCII</h1>
        <p class="subtitle">Convert your wireframes to ASCII art for AI prompts</p>

        <div class="error" id="error"></div>

        <div class="dropzone" id="dropzone">
            <div class="dropzone-icon">üìÅ</div>
            <div class="dropzone-text">
                <strong>Drop your .excalidraw file here</strong><br>
                or click to browse
            </div>
        </div>
        <input type="file" id="fileInput" accept=".excalidraw,.json">

        <div class="output-section" id="outputSection">
            <div class="options">
                <div class="option">
                    <input type="checkbox" id="showText" checked>
                    <label for="showText">Include text labels</label>
                </div>
                <div class="option">
                    <input type="checkbox" id="doubleLines">
                    <label for="doubleLines">Double-line borders</label>
                </div>
                <div class="option">
                    <label for="scale">Scale:</label>
                    <input type="number" id="scale" value="1" min="0.1" max="3" step="0.1">
                </div>
            </div>

            <div class="section-header">
                <span class="section-title">ASCII Output</span>
                <button class="btn btn-primary" id="copyBtn">Copy to clipboard</button>
            </div>
            <div class="output-container">
                <pre id="output"></pre>
            </div>
            <div class="stats" id="stats"></div>
        </div>
    </div>

    <script>
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const outputSection = document.getElementById('outputSection');
        const output = document.getElementById('output');
        const error = document.getElementById('error');
        const stats = document.getElementById('stats');
        const copyBtn = document.getElementById('copyBtn');
        const showTextCheckbox = document.getElementById('showText');
        const doubleLinesCheckbox = document.getElementById('doubleLines');
        const scaleInput = document.getElementById('scale');

        let currentData = null;

        dropzone.addEventListener('click', () => fileInput.click());
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('dragover');
        });
        dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) processFile(file);
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) processFile(e.target.files[0]);
        });

        [showTextCheckbox, doubleLinesCheckbox, scaleInput].forEach(el => {
            el.addEventListener('change', () => {
                if (currentData) renderASCII(currentData);
            });
        });

        copyBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(output.textContent).then(() => {
                const original = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                setTimeout(() => copyBtn.textContent = original, 1500);
            });
        });

        function processFile(file) {
            error.classList.remove('visible');
            
            if (!file.name.endsWith('.excalidraw') && !file.name.endsWith('.json')) {
                showError('Please select an .excalidraw or .json file');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    currentData = data;
                    renderASCII(data);
                } catch (err) {
                    showError('Invalid JSON file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function showError(msg) {
            error.textContent = msg;
            error.classList.add('visible');
            outputSection.classList.remove('visible');
        }

        function renderASCII(data) {
            const elements = data.elements || [];
            if (elements.length === 0) {
                showError('No elements found in file');
                return;
            }

            const scale = parseFloat(scaleInput.value) || 1;
            const showText = showTextCheckbox.checked;
            const doubleLines = doubleLinesCheckbox.checked;

            // Calculate bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            elements.forEach(el => {
                const x = el.x || 0;
                const y = el.y || 0;
                const w = el.width || 0;
                const h = el.height || 0;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + w);
                maxY = Math.max(maxY, y + h);
            });

            // Add padding
            const padding = 20;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;

            // Grid dimensions (2 chars per unit for aspect ratio)
            const gridW = Math.ceil((maxX - minX) * scale / 8);
            const gridH = Math.ceil((maxY - minY) * scale / 16);

            // Initialize grid with spaces
            const grid = Array(gridH).fill(null).map(() => Array(gridW).fill(' '));

            function toGrid(x, y) {
                return {
                    x: Math.floor((x - minX) * scale / 8),
                    y: Math.floor((y - minY) * scale / 16)
                };
            }

            function setChar(x, y, char) {
                if (x >= 0 && x < gridW && y >= 0 && y < gridH) {
                    grid[y][x] = char;
                }
            }

            function drawLine(x1, y1, x2, y2, char = '‚îÄ') {
                const p1 = toGrid(x1, y1);
                const p2 = toGrid(x2, y2);
                
                const dx = Math.abs(p2.x - p1.x);
                const dy = Math.abs(p2.y - p1.y);
                const sx = p1.x < p2.x ? 1 : -1;
                const sy = p1.y < p2.y ? 1 : -1;
                let err = dx - dy;

                let x = p1.x, y = p1.y;
                while (true) {
                    const isHorizontal = dy < dx;
                    setChar(x, y, isHorizontal ? '‚îÄ' : '‚îÇ');
                    
                    if (x === p2.x && y === p2.y) break;
                    const e2 = 2 * err;
                    if (e2 > -dy) { err -= dy; x += sx; }
                    if (e2 < dx) { err += dx; y += sy; }
                }
            }

            function drawRect(x, y, w, h) {
                const p = toGrid(x, y);
                const p2 = toGrid(x + w, y + h);
                const left = Math.min(p.x, p2.x);
                const right = Math.max(p.x, p2.x);
                const top = Math.min(p.y, p2.y);
                const bottom = Math.max(p.y, p2.y);

                const hLine = doubleLines ? '‚ïê' : '‚îÄ';
                const vLine = doubleLines ? '‚ïë' : '‚îÇ';
                const tl = doubleLines ? '‚ïî' : '‚îå';
                const tr = doubleLines ? '‚ïó' : '‚îê';
                const bl = doubleLines ? '‚ïö' : '‚îî';
                const br = doubleLines ? '‚ïù' : '‚îò';

                // Top and bottom
                for (let i = left + 1; i < right; i++) {
                    setChar(i, top, hLine);
                    setChar(i, bottom, hLine);
                }
                // Left and right
                for (let i = top + 1; i < bottom; i++) {
                    setChar(left, i, vLine);
                    setChar(right, i, vLine);
                }
                // Corners
                setChar(left, top, tl);
                setChar(right, top, tr);
                setChar(left, bottom, bl);
                setChar(right, bottom, br);
            }

            function drawDiamond(x, y, w, h) {
                const cx = x + w / 2;
                const cy = y + h / 2;
                const pTop = toGrid(cx, y);
                const pBottom = toGrid(cx, y + h);
                const pLeft = toGrid(x, cy);
                const pRight = toGrid(x + w, cy);

                drawLine(x, cy, cx, y, '‚ï±');
                drawLine(cx, y, x + w, cy, '‚ï≤');
                drawLine(x + w, cy, cx, y + h, '‚ï±');
                drawLine(cx, y + h, x, cy, '‚ï≤');

                // Fix corners
                setChar(pTop.x, pTop.y, '‚ï∑');
                setChar(pBottom.x, pBottom.y, '‚ïµ');
                setChar(pLeft.x, pLeft.y, '‚ï∂');
                setChar(pRight.x, pRight.y, '‚ï¥');
            }

            function drawEllipse(x, y, w, h) {
                const cx = x + w / 2;
                const cy = y + h / 2;
                const rx = w / 2;
                const ry = h / 2;

                const steps = Math.max(16, Math.floor((w + h) / 10));
                let prevP = null;
                
                for (let i = 0; i <= steps; i++) {
                    const angle = (i / steps) * Math.PI * 2;
                    const px = cx + rx * Math.cos(angle);
                    const py = cy + ry * Math.sin(angle);
                    const p = toGrid(px, py);
                    
                    if (prevP) {
                        const dx = p.x - prevP.x;
                        const dy = p.y - prevP.y;
                        if (Math.abs(dx) > Math.abs(dy)) {
                            setChar(p.x, p.y, '‚îÄ');
                        } else {
                            setChar(p.x, p.y, '‚îÇ');
                        }
                    }
                    prevP = p;
                }
            }

            function drawText(x, y, text) {
                if (!showText || !text) return;
                const p = toGrid(x, y);
                const chars = text.split('');
                for (let i = 0; i < chars.length; i++) {
                    setChar(p.x + i, p.y, chars[i]);
                }
            }

            // Sort elements by z-index
            const sortedElements = [...elements].sort((a, b) => (a.seed || 0) - (b.seed || 0));

            // Draw elements
            sortedElements.forEach(el => {
                const type = el.type;
                
                if (type === 'rectangle') {
                    drawRect(el.x, el.y, el.width, el.height);
                    if (el.boundElements) {
                        el.boundElements.forEach(be => {
                            const textEl = elements.find(e => e.id === be.id);
                            if (textEl && textEl.type === 'text') {
                                drawText(textEl.x, textEl.y, textEl.text);
                            }
                        });
                    }
                } else if (type === 'diamond') {
                    drawDiamond(el.x, el.y, el.width, el.height);
                } else if (type === 'ellipse') {
                    drawEllipse(el.x, el.y, el.width, el.height);
                } else if (type === 'line' || type === 'arrow') {
                    const points = el.points || [];
                    for (let i = 0; i < points.length - 1; i++) {
                        drawLine(
                            el.x + points[i][0],
                            el.y + points[i][1],
                            el.x + points[i + 1][0],
                            el.y + points[i + 1][1]
                        );
                    }
                    // Arrow head
                    if (type === 'arrow' && points.length >= 2) {
                        const last = points[points.length - 1];
                        const prev = points[points.length - 2];
                        const ax = el.x + last[0];
                        const ay = el.y + last[1];
                        const p = toGrid(ax, ay);
                        
                        // Simple arrow direction
                        const dx = last[0] - prev[0];
                        const dy = last[1] - prev[1];
                        if (Math.abs(dx) > Math.abs(dy)) {
                            setChar(p.x, p.y, dx > 0 ? '>' : '<');
                        } else {
                            setChar(p.x, p.y, dy > 0 ? 'v' : '^');
                        }
                    }
                } else if (type === 'text' && !el.containerId) {
                    drawText(el.x, el.y, el.text);
                }
            });

            // Convert to string
            const lines = grid.map(row => row.join('').replace(/\s+$/, ''));
            // Remove empty lines at start/end
            while (lines.length > 0 && lines[0].trim() === '') lines.shift();
            while (lines.length > 0 && lines[lines.length - 1].trim() === '') lines.pop();
            
            const ascii = lines.join('\n');
            output.textContent = ascii || '(empty result)';
            outputSection.classList.add('visible');
            
            stats.textContent = `${elements.length} elements ¬∑ ${gridW}√ó${gridH} grid ¬∑ ${ascii.length} chars`;
        }
    </script>
</body>
</html>
